{"version":3,"file":"index.js","sources":["../../node_modules/native-dash/dist/es/index.js","../../src/index.ts"],"sourcesContent":["var DataType;\r\n(function (DataType) {\r\n    DataType[\"null\"] = \"null\";\r\n    DataType[\"string\"] = \"string\";\r\n    DataType[\"number\"] = \"number\";\r\n    DataType[\"bigint\"] = \"bigint\";\r\n    DataType[\"symbol\"] = \"symbol\";\r\n    DataType[\"boolean\"] = \"boolean\";\r\n    DataType[\"function\"] = \"function\";\r\n    DataType[\"undefined\"] = \"undefined\";\r\n    /** an object with key-value pairs */\r\n    DataType[\"dictionary\"] = \"dictionary\";\r\n    /** an object of unknown type */\r\n    DataType[\"object\"] = \"object\";\r\n    /** an array of unknown type */\r\n    DataType[\"array\"] = \"array\";\r\n    /** an array of just strings */\r\n    DataType[\"stringArray\"] = \"string[]\";\r\n    /** an array of just numbers */\r\n    DataType[\"numberArray\"] = \"number[]\";\r\n    /** an array of just boolean flags */\r\n    DataType[\"booleanArray\"] = \"boolean[]\";\r\n    /** an array of just symbols */\r\n    DataType[\"symbolArray\"] = \"symbol[]\";\r\n    /** an array of just functions */\r\n    DataType[\"functionArray\"] = \"function[]\";\r\n    /** an array of just `undefined` values */\r\n    DataType[\"undefinedArray\"] = \"undefined[]\";\r\n    /** an array of just `null` values */\r\n    DataType[\"nullArray\"] = \"null[]\";\r\n    /** an array of empty objects */\r\n    DataType[\"objectArray\"] = \"object[]\";\r\n    /**\r\n     * An array of the _same_ type of dictionary\r\n     */\r\n    DataType[\"dictionaryArray\"] = \"dictionary[]\";\r\n})(DataType || (DataType = {}));\r\n/**\r\n * A type-guard to check whether a given variable is a non-null based object\r\n */\r\nfunction isNonNullObject(thingy) {\r\n    return typeof thingy === \"object\" && thingy !== null;\r\n}\n\nfunction atRandom(things, excluding = []) {\r\n    things = things.filter((i) => typeof excluding === \"function\" ? excluding(i) : !excluding.includes(i));\r\n    const random = Math.floor(Math.random() * things.length);\r\n    return things[random];\r\n}\n\n/**\r\n * Converts a utf-8 string into Base64\r\n *\r\n * @param input any string based input\r\n */\r\nfunction toBase64(input) {\r\n    const buffer = Buffer.from(input, \"utf-8\");\r\n    return buffer.toString(\"base64\");\r\n}\r\n/**\r\n * Converts a base64 string to utf-8.\r\n *\r\n * @param input a base64 string\r\n * @param isJson flag to indicate that the converted payload should be treated as JSON\r\n * and converted to a javascript object\r\n */\r\nfunction fromBase64(input, isJson = false) {\r\n    const buffer = Buffer.from(input, \"base64\");\r\n    return isJson\r\n        ? JSON.parse(buffer.toString(\"utf-8\"))\r\n        : buffer.toString(\"utf-8\");\r\n}\n\nfunction between(start, end) {\r\n    const diff = Math.abs(end - start) + 1;\r\n    const random = Math.floor(Math.random() * diff);\r\n    return start + random;\r\n}\n\n/**\r\n * Capitalizes the first character of the string passed in\r\n */\r\nfunction capitalize(input) {\r\n    if (typeof input !== \"string\") {\r\n        throw new Error(`Failed to capitalize \"${input}\" as it was not of type \"string\" [${typeof input}]`);\r\n    }\r\n    return input.slice(0, 1).toUpperCase() + input.slice(1);\r\n}\n\n/**\r\n * **Pascalize**\r\n *\r\n * converts string representations in camelCase, snake_case, or space separated\r\n * into a PascalCase representation.\r\n *\r\n * Note: _by default it also removes surrounding white space (if it exists) but it\r\n * can be preserved if you change the `preserveWhitespace` flag._\r\n */\r\nfunction pascalize(input, preserveWhitespace = false) {\r\n    const [_, preWhite, focus, postWhite] = /^(\\s*)(.*?)(\\s*)$/.exec(input);\r\n    const convertInteriorToCap = (i) => i.replace(/[ |_|-]+([0-9]*?[a-z|A-Z]{1})/gs, (_, p1) => p1.toUpperCase());\r\n    const startingToCap = (i) => i.replace(/^[_|-]*?([0-9]*?[a-z]{1})/gs, (_, p1) => p1.toUpperCase());\r\n    const replaceLeadingTrash = (i) => i.replace(/^[-_]/s, \"\");\r\n    const replaceTrailingTrash = (i) => i.replace(/[-_]$/s, \"\");\r\n    return `${preserveWhitespace ? preWhite : \"\"}${capitalize(replaceTrailingTrash(replaceLeadingTrash(convertInteriorToCap(startingToCap(focus)))))}${preserveWhitespace ? postWhite : \"\"}`;\r\n}\n\n/**\r\n * **Camelize**\r\n *\r\n * converts a string into _camelCase_.\r\n *\r\n * Note: _by default it also removes surrounding white space (if it exists) but it\r\n * can be preserved if you change the `preserveWhitespace` flag._\r\n */\r\nfunction camelize(input, preserveWhitespace = false) {\r\n    const pascal = pascalize(input, preserveWhitespace);\r\n    const [_, preWhite, focus, postWhite] = /^(\\s*)(.*?)(\\s*)$/.exec(pascal);\r\n    return ((preserveWhitespace ? preWhite : \"\") +\r\n        focus.replace(/^.*?([0-9]*?[a-z|A-Z]{1})/s, (_, p1) => p1.toLowerCase()) +\r\n        (preserveWhitespace ? postWhite : \"\"));\r\n}\n\n/**\r\n * Produces a _dasherized_ version of a passed in string by:\r\n *\r\n * 1. Replacing all interior whitespace with a dash\r\n * 2. Replacing capitalized letters with a dash followed by the lowercase variant.\r\n * 3. Replace underscores with dashes\r\n * 4. Ensuring that duplicate dashes are removed and that non-whitespaced\r\n * characters are not dashes\r\n *\r\n * Note: does not impact exterior whitespace, e.g., `  myDash  ` is translated to `  my-dash  ` and leading and closing white space is not transformed.\r\n */\r\nfunction dasherize(input) {\r\n    const [_, preWhite, focus, postWhite] = /^(\\s*)(.*?)(\\s*)$/.exec(input);\r\n    const replaceWhitespace = (i) => i.replace(/\\s/gs, \"-\");\r\n    const replaceUppercase = (i) => i.replace(/[A-Z]/g, (c) => `-${c[0].toLowerCase()}`);\r\n    const replaceLeadingDash = (i) => i.replace(/^-/s, \"\");\r\n    const replaceTrailingDash = (i) => i.replace(/-$/s, \"\");\r\n    const replaceUnderscore = (i) => i.replace(/_/g, \"-\");\r\n    const removeDupDashes = (i) => i.replace(/-+/g, \"-\");\r\n    return `${preWhite}${replaceUnderscore(replaceTrailingDash(replaceLeadingDash(removeDupDashes(replaceWhitespace(replaceUppercase(focus))))))}${postWhite}`;\r\n}\n\n/**\r\n * Describes the types of the run-time data structure.\r\n */\r\nfunction describe(data) {\r\n    if (!isNonNullObject(data)) {\r\n        return data === null ? DataType.null : DataType[typeof data];\r\n    }\r\n    if (Array.isArray(data)) {\r\n        if (data.length === 0) {\r\n            return DataType.array;\r\n        }\r\n        // TODO: look into something more sophisticated\r\n        const SAMPLE_SIZE = 5;\r\n        const partial = data.slice(0, SAMPLE_SIZE);\r\n        const elements = partial.map((p) => describe(p));\r\n        return elements;\r\n        // const allTheSame = elements.length === 1 || elements.slice(1).every((i) => equal());\r\n    }\r\n    if (Object.keys(data).length === 0) {\r\n        return DataType.object;\r\n    }\r\n    const dictionary = data;\r\n    const dataStruct = Object.keys(dictionary).reduce((agg, key) => {\r\n        return {\r\n            ...agg,\r\n            ...(isNonNullObject(dictionary[key])\r\n                ? { [key]: describe(dictionary[key]) }\r\n                : { [key]: typeof dictionary[key] }),\r\n        };\r\n    }, {});\r\n    return dataStruct;\r\n}\n\nfunction deserialize(arr) {\r\n    return arr.split(\"\\n\").map((i) => JSON.parse(i));\r\n}\n\n/**\r\n * Provides the _keys_ of an object with the keys returned explicitly\r\n * as `keyof T`.\r\n */\r\nfunction keys(obj) {\r\n    return Object.keys(obj);\r\n}\n\n/**\r\n * Converts a dictionary object into a key-value array\r\n */\r\nfunction kv(obj) {\r\n    if (typeof obj !== \"object\" || obj === null) {\r\n        throw new Error(\"Value passed into kv() must be an object\");\r\n    }\r\n    return keys(obj).reduce((acc, key) => {\r\n        const value = obj[key];\r\n        return [...acc, { key, value }];\r\n    }, []);\r\n}\n\n/** simple type of a variable */\r\nfunction type(v) {\r\n    return Array.isArray(v) ? DataType.array : v === null ? DataType.null : typeof v;\r\n}\r\n/**\r\n * Compare two variables for equality, and optionally specify a _depth_ for dictionaries.\r\n */\r\nfunction equal(a, b, depth = 1) {\r\n    const ta = type(a);\r\n    const tb = type(b);\r\n    if (ta !== tb) {\r\n        return false;\r\n    }\r\n    // note: ta == tb\r\n    switch (ta) {\r\n        case DataType.null:\r\n        case undefined:\r\n            return true;\r\n        case \"boolean\":\r\n        case \"string\":\r\n        case \"symbol\":\r\n        case \"number\":\r\n        case \"bigint\":\r\n            return a === b;\r\n        case DataType.array:\r\n            if (a.length !== b.length) {\r\n                return false;\r\n            }\r\n            return a.every((v, idx) => equal(v, b[idx]));\r\n        case \"object\":\r\n            const ka = kv(a);\r\n            const kb = kv(b);\r\n            if (ka.length !== kb.length) {\r\n                return false;\r\n            }\r\n            return ka.every((i) => type(i.value) === \"object\"\r\n                ? depth > 0\r\n                    ? equal(i.value, b[i.key], depth - 1)\r\n                    : false\r\n                : i.value === b[i.key]);\r\n        default:\r\n            return a === b;\r\n    }\r\n}\n\n/**\r\n * **first**\r\n *\r\n * returns the first item in an array\r\n */\r\nfunction first(arr) {\r\n    return arr.slice(0, 1)[0];\r\n}\n\n/**\r\n * **firstKey**\r\n *\r\n * returns the _first_ key in a dictionary or `false` if there are no\r\n * keys in the object passed in.\r\n */\r\nfunction firstKey(dict) {\r\n    const key = Object.keys(dict).slice(0, 1).pop();\r\n    return key ? key : false;\r\n}\n\n/**\r\n * **flatten**\r\n *\r\n * > If you know that your run-time supports using the native `[ ].flat()` language feature\r\n * (which all modern node runtimes and browsers largely outside of IE11 do then you should\r\n * use this instead).\r\n */\r\nfunction flatten(arr) {\r\n    return arr.flat ? arr.flat() : arr.reduce((acc, val) => acc.concat(val), []);\r\n}\n\n/**\r\n * **get**\r\n *\r\n * Gets a value in a deeply nested object. This is a replacement to `lodash.get`\r\n *\r\n * @param obj the base object to get the value from\r\n * @param dotPath the path to the object, using \".\" as a delimiter\r\n * @param defaultValue optionally you may state a default value if the operation results in `undefined`\r\n */\r\nfunction get(obj, dotPath, defaultValue) {\r\n    const parts = dotPath.split(\".\");\r\n    let value = obj;\r\n    parts.forEach((p) => {\r\n        value = typeof value === \"object\" && Object.keys(value).includes(p) ? value[p] : undefined;\r\n    });\r\n    return value ? value : defaultValue;\r\n}\n\n/**\r\n * Provides a dependency-free method of generating\r\n * a useful 4 character random string.\r\n *\r\n * > **Note:** if you want a GUID then use the `guid()`\r\n * function instead which leverages this function but\r\n * puts it into the proper GUID format\r\n */\r\nfunction randomString() {\r\n    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\r\n}\n\n/**\r\n * Produces a UUID with 32 random string characters.\r\n *\r\n * By default this will use the dasherized convention of **uuid** but you can\r\n * turn this off and just output the random string characters.\r\n */\r\nfunction uuid(dasherized = true) {\r\n    return dasherized\r\n        ? randomString() +\r\n            randomString() +\r\n            \"-\" +\r\n            randomString() +\r\n            \"-\" +\r\n            randomString() +\r\n            \"-\" +\r\n            randomString() +\r\n            \"-\" +\r\n            randomString() +\r\n            randomString() +\r\n            randomString()\r\n        : randomString() +\r\n            randomString() +\r\n            randomString() +\r\n            randomString() +\r\n            randomString() +\r\n            randomString() +\r\n            randomString() +\r\n            randomString();\r\n}\n\n/**\r\n * Produces a dasherized random ID\r\n *\r\n * @deprecated please use `uuid` instead\r\n */\r\nfunction guid() {\r\n    return uuid();\r\n}\n\n/**\r\n * Provides a hashing function which produces a 32-bit integer\r\n * hash which provides idempotency.\r\n *\r\n * This function is not intended to be used in situations where\r\n * there is need for strong cryptographic assurances but rather\r\n * where a _very_ lightweight hasher is desired.\r\n *\r\n * For more information on this hash function refer to the discussion\r\n * on stackoverflow: https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\r\n *\r\n * @param digest the text digest to be hashed\r\n */\r\nfunction hash(digest) {\r\n    let hash = 0, i, chr;\r\n    for (i = 0; i < digest.length; i++) {\r\n        chr = digest.charCodeAt(i);\r\n        hash = (hash << 5) - hash + chr;\r\n        hash |= 0; // Convert to 32bit integer\r\n    }\r\n    return hash;\r\n}\n\n/**\r\n * Checks whether a given number is an _odd_ number.\r\n */\r\nfunction isEven(value) {\r\n    return value % 2 ? false : true;\r\n}\n\n/**\r\n * Tests whether the passed in year is a leap year or not\r\n */\r\nfunction isLeapYear(year) {\r\n    const y = typeof year === \"number\" ? year : year.getFullYear();\r\n    return new Date(y, 1, 29).getDate() === 29;\r\n}\n\n/**\r\n * Checks whether a given number is an _odd_ number.\r\n */\r\nfunction isOdd(value) {\r\n    return value % 2 ? true : false;\r\n}\n\n/**\r\n * Tests whether the passed in string is a valid GUID. Valid GUID's\r\n * must be of the format. This is typically expressed in a **RegExp** as:\r\n *\r\n * ```ts\r\n * /^(\\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\\}{0,1})$/\r\n * ```\r\n *\r\n * However, the dashes are not a strict requirement, so you may choose to validate\r\n * using both the above format and the non-dasherized version. Default behavior is _not_\r\n * to allow the non-dasherized form.\r\n */\r\nfunction isUuid(candidate, allowNonDashedForm) {\r\n    const dasherizedGuid = /^(\\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\\}{0,1})$/;\r\n    const plainGuid = /^(\\{{0,1}([0-9a-fA-F]){32}\\}{0,1})$/;\r\n    return allowNonDashedForm === true\r\n        ? plainGuid.test(candidate) || dasherizedGuid.test(candidate)\r\n        : dasherizedGuid.test(candidate);\r\n}\n\n/**\r\n * **last**\r\n *\r\n * returns the last item in an array\r\n */\r\nfunction last(arr) {\r\n    return arr.slice(-1)[0];\r\n}\n\n/**\r\n * **lastKey**\r\n *\r\n * returns the _last_ key in a dictionary or `false` if there are no\r\n * keys in object passed in.\r\n */\r\nfunction lastKey(dict) {\r\n    const key = Object.keys(dict).slice(-1).pop();\r\n    return key ? key : false;\r\n}\n\n/**\r\n * **omit**\r\n *\r\n * Removes/omits properties of an object and returns a shallow copy with props\r\n * removed and with typescript types updated to reflect this removal.\r\n *\r\n * @param obj the starting state object\r\n * @param removals an array of properties to be removed from the object\r\n */\r\nfunction omit(obj, ...removals) {\r\n    const untyped = removals;\r\n    return Object.fromEntries(Object.entries(obj).filter(([key]) => !untyped.includes(key)));\r\n}\n\n/**\r\n * Joins a set of paths together into a single path.\r\n *\r\n * **Note:** trailing path never includes a `/` so add this at the end if\r\n * you need it.\r\n *\r\n * **Note:** the \"..\" characters are allowed in starting string but in no\r\n * other.\r\n *\r\n * **Note:** any use of the Windows \"\\\\\" will be converted to the Posix \"/\"\r\n */\r\nfunction pathJoin(...args) {\r\n    const leadingSlash = args[0] && (args[0].startsWith(\"/\") || args[0].startsWith(\"\\\\\"));\r\n    const parts = args\r\n        .filter((i) => i)\r\n        .map((i) => removeSlashAtFrontAndBack(makeForwardSlashBeBackward(i)));\r\n    if (parts.slice(1).some((i) => i.includes(\"..\"))) {\r\n        throw new Error(`pathJoin() only accepts the \"..\" notation at the beginning of the first string and no where else. Input was invalid: ${JSON.stringify(args)}`);\r\n    }\r\n    return `${leadingSlash ? \"/\" : \"\"}${parts.join(\"/\")}`;\r\n}\r\nfunction removeSlashAtFrontAndBack(input) {\r\n    input = input.startsWith(\"/\") ? input.slice(1) : input;\r\n    input = input.endsWith(\"/\") ? input.slice(0, input.length - 1) : input;\r\n    return input;\r\n}\r\nfunction makeForwardSlashBeBackward(input) {\r\n    return input.replace(/\\\\/gs, \"/\");\r\n}\n\n/** Rules were derived from [Grammarly](https://www.grammarly.com/blog/plural-nouns/) */\r\nconst defaultRules = [\r\n    // ending in \"us\"\r\n    [/(us)$/, (i) => `${i.replace(/us$/, \"\")}i`, [\"bus\", \"us\"]],\r\n    // \"is\" to \"es\"\r\n    [/(is)$/, (i, r) => `${i.replace(r, \"\")}es`],\r\n    // singular noun endings that have \"es\" added\r\n    [/(s|sh|ch|x|z|o)$/, (i) => `${i}es`],\r\n    // ending in \"f\" or \"fe\"\r\n    [/fe{0,1}$/, (i, r) => `${i.replace(r, \"\")}ves`],\r\n    // end in Y, with consonant before it\r\n    [\r\n        /[b|c|d|f|g|h|j|k|l|m|n|p|q|r|s|t|v|w|x|z|y]y$/,\r\n        (i) => `${i.slice(0, i.length - 1)}ies`,\r\n    ],\r\n];\r\nvar Rule;\r\n(function (Rule) {\r\n    Rule[Rule[\"regex\"] = 0] = \"regex\";\r\n    Rule[Rule[\"fn\"] = 1] = \"fn\";\r\n    Rule[Rule[\"exceptions\"] = 2] = \"exceptions\";\r\n})(Rule || (Rule = {}));\r\nvar ExplicitRule;\r\n(function (ExplicitRule) {\r\n    ExplicitRule[ExplicitRule[\"singular\"] = 0] = \"singular\";\r\n    ExplicitRule[ExplicitRule[\"plural\"] = 1] = \"plural\";\r\n})(ExplicitRule || (ExplicitRule = {}));\r\n/**\r\n * A simple and light weight pluralizer utility.\r\n */\r\nfunction pluralize(input, options = {}) {\r\n    if (input === \"\") {\r\n        if (options.ignoreEmptyStrings)\r\n            return \"\";\r\n        throw new Error(\"Attempt to pluralize an empty string\");\r\n    }\r\n    const defaultExceptions = {\r\n        photo: \"photos\",\r\n        piano: \"pianos\",\r\n        halo: \"halos\",\r\n        foot: \"feet\",\r\n        man: \"men\",\r\n        woman: \"women\",\r\n        person: \"people\",\r\n        mouse: \"mice\",\r\n        series: \"series\",\r\n        sheep: \"sheep\",\r\n        deer: \"deer\",\r\n    };\r\n    const exceptions = {\r\n        ...defaultExceptions,\r\n        ...(options.explictPluralizations ? options.explictPluralizations : {}),\r\n    };\r\n    if (Object.keys(exceptions).includes(input)) {\r\n        return exceptions[input];\r\n    }\r\n    const pRules = options.rules || options.additionalRules\r\n        ? defaultRules.concat(...options.additionalRules)\r\n        : defaultRules;\r\n    const rules = pRules.filter((r) => r[Rule.regex].test(input) && !(r[Rule.exceptions] || []).includes(input));\r\n    if (rules.length > 0) {\r\n        const [r, fn, exceptions] = rules[0];\r\n        return fn(input, r, exceptions || []);\r\n    }\r\n    else {\r\n        return `${input}s`;\r\n    }\r\n}\n\n/**\r\n * **retain**\r\n *\r\n * Retains an explicit set of key/value pairs on a dictionary and ensures both\r\n * runtime value and type system remove the other properties.\r\n *\r\n * @param obj the starting state object\r\n * @param retainedProps an array of properties to be _retained_ on the object\r\n */\r\nfunction retain(obj, ...retainedProps) {\r\n    const untyped = retainedProps;\r\n    return Object.fromEntries(Object.entries(obj).filter(([key]) => untyped.includes(key)));\r\n}\n\n// import type { Request} from  'node-fetch'\r\n// export type url = [url: string, fetch: typeof fetch];\r\n// export type filename = string;\r\n/**\r\n * converts an array of _things_ into a `\\n` delimited\r\n * string of stringified objects.\r\n *\r\n * FUTURE: If a **source** is passed in\r\n * -- either a _file_ or _url_ then it will stream to that\r\n * source.\r\n *\r\n */\r\nfunction serialize(arr /** , source?: url | filename **/) {\r\n    return arr.map((i) => JSON.stringify(i)).join(\"\\n\");\r\n}\n\n/**\r\n * Sets a value at a nested point within base object passed in. This is meant as a\r\n * replacement to use of `lodash.set()`.\r\n *\r\n * @param obj the base object which is being mutated\r\n * @param dotPath the path into the object where the mutation will take place, delimited by `.`\r\n * @param value The value to set at the _dotPath_\r\n * @param createIfNonExistant by default, if the path to the object does not exist then an error is thrown but if you want you can state the desire to have the full path created\r\n */\r\nfunction set(obj, dotPath, value, createIfNonExistant = true) {\r\n    if (!dotPath) {\r\n        throw new Error(`Attempt to set value into a dotPath but the dotPath was empty!`);\r\n    }\r\n    const parts = dotPath.split(/\\??\\./);\r\n    const allButLast = parts.slice(0, parts.length - 1);\r\n    const key = parts.pop();\r\n    let ref = obj;\r\n    // iterate the ref to the leaf node\r\n    allButLast.forEach((p) => {\r\n        if (!ref[p]) {\r\n            if (createIfNonExistant) {\r\n                ref[p] = {};\r\n            }\r\n            else {\r\n                throw new Error(`The dotPath -- ${dotPath} -- does not exist in the passed in object. You must either expressly state that you want the object structure created or this a real error that must be addressed otherwise. The part of the path which this failed on was \"${p}\".`);\r\n            }\r\n        }\r\n        else if (typeof ref[p] !== \"object\") {\r\n            throw new Error(`Failed to set the path of \"${dotPath}\" of the passed in base object because the base object had a scalar value along that path and setting this would have changed the object's data structure in way which is not allowed! The scalar value was found in the \"${p}\" component of the path.`);\r\n        }\r\n        ref = ref[p];\r\n    });\r\n    ref[key] = value;\r\n}\n\n/**\r\n * **Snakerize**\r\n *\r\n * Converts a string to snake_case notation.\r\n *\r\n * Note: _by default it also removes surrounding white space (if it exists) but it\r\n * can be preserved if you change the `preserveWhitespace` flag._\r\n */\r\nfunction snakerize(input, preserveWhitespace = false) {\r\n    const [_, preWhite, focus, postWhite] = /^(\\s*)(.*?)(\\s*)$/.exec(input);\r\n    const convertInteriorSpace = (input) => input.replace(/\\s+/gs, \"_\");\r\n    const convertDashes = (input) => input.replace(/-/gs, \"_\");\r\n    const injectUnderscoreBeforeCaps = (input) => input.replace(/([A-Z])/gs, \"_$1\");\r\n    const removeLeadingUnderscore = (input) => input.startsWith(\"_\") ? input.slice(1) : input;\r\n    return ((preserveWhitespace ? preWhite : \"\") +\r\n        removeLeadingUnderscore(injectUnderscoreBeforeCaps(convertDashes(convertInteriorSpace(focus)))).toLowerCase() +\r\n        (preserveWhitespace ? postWhite : \"\"));\r\n}\n\n/**\r\n * Provides the unique values for a given property in an array of\r\n * commonly typed objects.\r\n *\r\n * @param list the list of objects\r\n * @param property the property to evaluate\r\n */\r\nfunction unique(list, property) {\r\n    return Array.from(new Set(list.map((i) => i[property])));\r\n}\n\nconst RESET_FG = `\\u001b[39m`;\r\nconst RESET_BG = `\\u001b[49m`;\r\n/**\r\n * A dictionary of colors; first value is foreground,\r\n * second is background.\r\n */\r\nconst COLOR = {\r\n    black: [30, 40],\r\n    red: [31, 41],\r\n    magenta: [35, 45],\r\n    yellow: [33, 43],\r\n    green: [32, 42],\r\n    brightRed: [91, 40],\r\n    brightGreen: [92, 42],\r\n    brightYellow: [93, 43],\r\n};\n\nfunction paint(text = \"\", fg, bg) {\r\n    const foreground = \"\\u001b[\" + fg(COLOR)[0] + \"m\";\r\n    const bgc = bg ? bg(COLOR)[1] : null;\r\n    const background = bgc ? \"\\u001b[\" + bgc + \"m\" : \"\";\r\n    const reset = background ? `${RESET_FG}${RESET_BG}` : `${RESET_FG}`;\r\n    return `${RESET_FG}${foreground}${background}${text}${reset}`;\r\n}\n\n/** _italicize_ a block of text */\r\nfunction italicize(text = \"\") {\r\n    return `\\u001b[3m${text}\\u001b[0m`;\r\n}\r\n/** _underline_ a block of text */\r\nfunction underline(text = \"\") {\r\n    return `\\u001b[4m${text}\\u001b[0m`;\r\n}\r\n/** ~strikethrough~ a block of text (not supported on many terminals) */\r\nfunction strikethrough(text = \"\") {\r\n    return `\\u001b[9m${text}\\u001b[0m`;\r\n}\r\n/**\r\n * Look through a _corpus_ of text for a particular string and\r\n * then format for the console.\r\n */\r\n// export function format(find: string, global: boolean = true) {\r\n//   let config: IFormattingOptions = {};\r\n//   return formattingApi<\"in\">(find, global, config);\r\n// }\n\n/**\r\n * Colorize text in the console.\r\n *\r\n * Choose a foreground color and optionally a background color.\r\n */\r\nconst color = {\r\n    red: (text = \"\", bg) => {\r\n        return paint(text, (c) => c.red, bg);\r\n    },\r\n    magenta: (text = \"\", bg) => {\r\n        return paint(text, (c) => c.magenta, bg);\r\n    },\r\n    black: (text = \"\", bg) => {\r\n        return paint(text, (c) => c.black, bg);\r\n    },\r\n    yellow: (text = \"\", bg) => {\r\n        return paint(text, (c) => c.yellow, bg);\r\n    },\r\n    green: (text = \"\", bg) => {\r\n        return paint(text, (c) => c.green, bg);\r\n    },\r\n    brightRed: (text = \"\", bg) => {\r\n        return paint(text, (c) => c.brightRed, bg);\r\n    },\r\n};\n\nexport { DataType, atRandom, between, camelize, capitalize, color, dasherize, describe, deserialize, equal, first, firstKey, flatten, fromBase64, get, guid, hash, isEven, isLeapYear, isNonNullObject, isOdd, isUuid, italicize, keys, kv, last, lastKey, omit, pascalize, pathJoin, pluralize, randomString, retain, serialize, set, snakerize, strikethrough, toBase64, underline, unique, uuid };\n","import { IDictionary } from \"common-types\";\nimport { get } from \"native-dash\";\n\nexport interface ISnapShot {\n  val: () => any;\n  key: string;\n  forEach(mapper: (child: ISnapShot) => boolean): void;\n}\n\nexport function removeIdPropertyFromHash<T = IDictionary>(\n  hash: IDictionary<T>,\n  idProp = \"id\"\n) {\n  const output: any = {};\n  Object.keys(hash).map((objId) => {\n    const input: IDictionary = hash[objId];\n    output[objId] = {};\n    Object.keys(input).map((prop) => {\n      if (prop !== idProp) {\n        output[objId][prop] = input[prop];\n      }\n    });\n  });\n  return output;\n}\n\nexport function keyValueDictionaryToArray<T = any>(\n  dict: IDictionary<T>,\n  options: IDictionary = {}\n) {\n  const __key__ = options.key || \"id\";\n  const __value__ = options.value || \"value\";\n  return Object.keys(dict).reduce((result, key) => {\n    return result.concat({ [__key__]: key, [__value__]: dict[key] });\n  }, []);\n}\n\nexport function keyValueArrayToDictionary<T = any>(\n  input: T[],\n  options: IDictionary = {}\n): IDictionary {\n  const __key__ = options.key || \"key\";\n  const __value__ = options.value || \"value\";\n  return input.reduce((output: any, curr: IDictionary) => {\n    const key = curr[__key__];\n    const value = curr[__value__];\n\n    output[key] = value;\n    return output;\n  }, {});\n}\n\n/**\n * hashToArray\n *\n * Converts a hash data structure of {key: value, key2: value2} to an\n * array of [ {id, value}, {id2, value2} ]. This should happen regardless\n * to whether the values are themselves hashes (which they often are) or\n * scalar values.\n *\n * The one edge case is where all the hashes passed in have a value of \"true\"\n * which indicates that this really just a simple value based array encoded as\n * a hash (as is often the case in Firebase for FK relationships).\n *\n * @param hashObj an object of keys that point to some data payload\n * @param ___key__ the property name on the converted array-of-hashes which will contain the key value; by default this is \"id\"\n */\nexport function hashToArray<T = any>(\n  hashObj: IDictionary<T> | IDictionary<string> | IDictionary<number>,\n  __key__: keyof (T & { id: string }) = \"id\"\n) {\n  if (hashObj && typeof hashObj !== \"object\") {\n    throw new Error(\n      \"Cant convert hash-to-array because hash was not passed in: \" + hashObj\n    );\n  }\n  const hash: IDictionary = { ...{}, ...hashObj };\n  const results: T[] = [];\n  const isHashArray = Object.keys(hash).every((i) => hash[i] === true);\n  const isHashValue = Object.keys(hash).every(\n    (i) => typeof hash[i] !== \"object\"\n  );\n\n  Object.keys(hash).map((id) => {\n    const obj =\n      typeof hash[id] === \"object\"\n        ? { ...hash[id], [__key__]: id }\n        : isHashArray\n          ? id\n          : { [__key__]: id, value: hash[id] };\n\n    results.push(obj);\n  });\n  return results;\n}\n\nexport function flatten<T = any>(list: any): T[] {\n  return list.reduce(\n    (a: any, b: any) => a.concat(Array.isArray(b) ? flatten(b) : b),\n    []\n  );\n}\n\nexport type FunctionProperty<T> = (obj: T) => string;\n\n/**\n * arrayToHash\n *\n * Converts an array of things into a hash/dictionary where \"things\" is a consistent\n * type of data structure (can be either object or primitive)\n *\n * @param arr an array of a particular type\n * @param keyProperty the property that will be used as the dictionaries key; if false\n * then will assign a firebase pushkey\n * @param removeIdProperty allow you to optionally exclude the `id` from the object\n * as it is redundant to the `key` of the hash. By default though, this is _not_ done as\n * Firemodel benefits (and expects) from this duplication.\n */\nexport function arrayToHash<T = any>(\n  arr: T[],\n  keyProperty?: keyof T | FunctionProperty<T>,\n  removeIdProperty: boolean = false\n): IDictionary<T> {\n  if (arr.length === 0) {\n    return {};\n  }\n\n  const isScalar: boolean = typeof arr[0] === \"object\" ? false : true;\n  if (isScalar && keyProperty) {\n    const e = new Error(\n      `You can not have an array of primitive values AND set a keyProperty!`\n    );\n    e.name = \"NotAllowed\";\n    throw e;\n  }\n\n  if (!keyProperty && !isScalar) {\n    if (arr[0].hasOwnProperty(\"id\")) {\n      keyProperty = \"id\" as keyof T;\n    } else {\n      const e = new Error(\n        `Tried to default to a keyProperty of \"id\" but that property does not appear to be in the array passed in`\n      );\n      e.name = \"NotAllowed\";\n      throw e;\n    }\n  }\n\n  if (!Array.isArray(arr)) {\n    const e = new Error(`arrayToHash: input was not an array!`);\n    e.name = \"NotAllowed\";\n    throw e;\n  }\n\n  const output: IDictionary<T> = arr.reduce((prev, curr) => {\n    const key = isScalar\n      ? curr\n      : typeof keyProperty === \"function\"\n        ? (keyProperty(curr) as keyof T)\n        : curr[keyProperty];\n\n    return isScalar\n      ? { ...prev, ...{ [key as any]: true } }\n      : { ...prev, ...{ [key as any]: curr } };\n  }, {});\n\n  return removeIdProperty ? removeIdPropertyFromHash(output) : output;\n}\n\n/**\n * Snapshot to Array (unordered)\n *\n * converts snapshot directly to JS and then converts hash to an\n * array structure but any sorting that came from the server query\n * will be ignored.\n */\nexport function snapshotToArray<T = IDictionary>(\n  snap: ISnapShot,\n  idProp: string = \"id\"\n): T[] {\n  const hash: IDictionary = snap.val() || {};\n\n  return hashToArray(hash, idProp);\n}\n\n/**\n * Converts a Firebase snapshot to JS object with both val() and key\n * represented in the JS object\n *\n * @param snap the Firebase Snapshot\n * @param idProp the property used to store the \"id/key\" of the record\n */\nexport function snapshotToHash<T = IDictionary>(\n  snap: ISnapShot,\n  idProp: string = \"id\"\n): T {\n  const hash: IDictionary = snap.val() || {};\n  Object.keys(hash).forEach((key) =>\n    typeof hash[key] === \"object\"\n      ? (hash[key][idProp] = key)\n      : (hash[key] = { [idProp]: key, value: hash[key] })\n  );\n  return hash as T;\n}\n\n/**\n * Snapshot to Array (ordered)\n *\n * uses Firebase forEach() iterator to gain the appropriate sorting from the query.\n */\nexport function snapshotToOrderedArray<T = IDictionary>(\n  snap: ISnapShot,\n  idProp = \"id\"\n): T[] {\n  const output: T[] = [];\n  snap.forEach((child: ISnapShot) => {\n    const obj: any = child.val();\n    const key: string = child.key;\n    if (typeof obj !== \"object\") {\n      throw new Error(\n        `Can't create a list from scalar values: \"${obj}\" | \"${key}\"`\n      );\n    }\n    output.push({ ...{ [idProp]: key }, ...obj });\n\n    return true;\n  });\n\n  return output as T[];\n}\n\nexport function snapshotToOrderedHash<T = IDictionary>(\n  snap: ISnapShot,\n  idProp = \"id\"\n): IDictionary<T> {\n  const orderedArray = this.snapshotToOrderedArray(snap, idProp);\n  return this.arrayToHash(orderedArray);\n}\n\n/**\n *\n * @param dictionary A dictionary of a structured type\n * @param property Which property in each dictionary item are we getting\n */\nexport function getPropertyAcrossDictionaryItems<T>(\n  dictionary: IDictionary,\n  property: string\n): T[] {\n  const output: any[] = [];\n  Object.keys(dictionary).map((item) => {\n    const value = get(dictionary[item], property);\n    if (value !== undefined) {\n      output.push(value);\n    }\n  });\n\n  return output;\n}\n"],"names":[],"mappings":"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"}